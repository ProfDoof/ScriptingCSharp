<p>The purpose of this assignment is to practice C++ class implementation for 
a generic programming, value semantic object with copy-on-write, and operator 
overloading. Create the type Tuple which implements the mathematical concept 
of a vector or n-tuple.</p>

<p>The following code represents how Tuple might be used:</P>

<pre class=file>
double x[] = (1,2,3,4,5);
Tuple&lt;int&gt; i(5);         // create a zero-filled n-tuple
Tuple&lt;double&gt; d(x,5)     // create n-tuple from x[]

cout &lt;&lt; i.size();         // number of elements
cout &lt;&lt; d.magnitude();    // <u><a href=http://en.wikipedia.org/wiki/Euclidean_vector#Length>Euclidean norm</a></u> of the vector
</pre>

<p>If <tt>A</tt> and <tt>B</tt> are Tuples of the same type, <tt>x</tt> is a 
value of the same type, and <tt>i</tt> is an integer, then the following 
operations should work:</p>

<pre class=file>
A + B, A += B            element-wise addition of zero-extended vectors,
                         resultant vector is size of longest operand
                         
A * B                    <u><a href=http://en.wikipedia.org/wiki/Euclidean_vector#Dot_product>dot product</a></u> of two vectors, 
                         result is scalar
                         
x * A, A * x, A *= x     <u><a href=http://en.wikipedia.org/wiki/Euclidean_vector#Scalar_multiplication>scalar multiplication</a></u> of vector and a scalar

A == B                   A exactly equals B, zero-extended as needed

A != B                   A does not equal B, zero-extended as needed

A[i]                     if 0&le;i&lt;size refers to ith element, 
                         otherwise 0, both l- and r-value
</pre>

<p>Your solution should allow "low cost" value semantics as long as the 
underlying elements are not changed, but without requiring the value objects 
to be const. Using copy-on-write stategy and implementing a hand-body design 
to hide the reference counting. Any operation which changes (or potentially 
changes) an element should create a copy of the underlying elements.</p>

<p>In order to test you implementation, if <tt>DEBUG</tt> is defined, the 
implementation function should return a reference to an object of type 
TupleData, which should provide the following functions:

<pre class=file>
size()                number of elements in the vector
useCount()            number of "co-owners"
[i]                   if 0&le;i&lt;size refers to ith element, otherwise 0, both l- and r-value
</pre>

You solution correctly manage access to private members and functions, be 
const correct, have appropriate order of operation time, implement operations 
only once, have canonical form (i.e., act like a value object), be commented, 
and so forth.

The following code is a partial example of how your class will be tested.       

<pre class=file>
Tuple&lt;int> add(Tuple&lt;int&gt; a,Tuple&lt;int&gt; b,Tuple&lt;int&gt; c)
{
   return a+b+c;     // allocation for 2 anonymous objects, deallocation for 1 of them
}

int main()
{
   Tuple&lt;int&gt; x(3);  // allocation of 3 ints
   Tuple&lt;int&gt; y(5);  // allocation of 5 ints
   x[0] = 2;         // no allocation, only one "user" of data
   x[1] = 3;
   x[2] = 7;
   y = x;            // deallocation of 5 ints, share 3 ints
   Tuple&lt;int&gt; z(x);  // no allocation, another shared copy
   z[3] = 9;         // no allocation, z[3] is undefined so its a no-op
   z[1] = 5;         // copy/split occurs before write to element 1
   z += x;           // no allocation, z has its own copy
   x = foo(x,y,x);   // no memory allocation should occur due to copy construction
}
</pre>
